"""尝试将STC(三元压缩)整合进FLAD中, 并评测其效果包括Residue(残差累积)模块"""import tensorflow as tfimport numpy as npdef approx_v(T, p):    """    估计稀疏化阈值v，选择前p%最大元素.    T: 模型更新的差异张量.    p: 稀疏率, 如0.001表示前0.1%的元素被保留.    """    T_flat = tf.reshape(tf.abs(T), -1)    k = tf.cast(tf.math.ceil(tf.size(T_flat, out_type=tf.float32) * p), tf.int32)    top_k, _ = tf.math.top_k(T_flat, k=k)    v = top_k[-1]  # 门槛    return v, top_kdef stc(T: tf.Tensor, hp):    """    STC稀疏三值压缩方法实现    T: 需要压缩的张量（模型差异）    hp: 超参数    返回压缩后的张量    """    hp_ = {'p': 0.1, 'approx': 1.0}    hp_.update(hp)    T_abs = tf.abs(T)    v, topk = approx_v(T_abs, hp_['p'])    mean = tf.reduce_mean(topk)    zeros = tf.zeros_like(T)    out_ = tf.where(T >= v, mean, zeros)    out = tf.where(T <= -v, -mean, out_)    return outdef decompress_stc(T_compressed):    """    因为STC只使用三值量化，因此解压缩就是直接返回压缩后的张量。    在实际应用中，这一步和压缩是对称的。    """    return T_compressed#  计算通讯量的方法def get_stc_update_size(T_compressed):    """    计算压缩后的STC模型更新通信量（MB）.    STC每个非零值使用1 bit表示，位置编码平均大约16 bit.    """    T_flat = tf.reshape(T_compressed, [-1])    k = tf.math.count_nonzero(T_flat, dtype=tf.float32)    total_bits = k * (1 + 16)  # 值编码1bit + 位置编码约16bits    size_MB = (total_bits / 8) / (1024**2)  # bits 转换为 MB    return size_MB.numpy()def calculate_compressed_update_size(compressed_update):    """    计算STC压缩后的通信量（MB）    compressed_update: 客户端压缩后的模型更新 (模型的各层)    每个非零值约17 bits (1位表示符号, 16位表示位置)    """    total_bits = 0    for layer in compressed_update:        nonzero_count = np.count_nonzero(layer)        bits_per_layer = nonzero_count * 17  # 每个非零元素17 bits        total_bits += bits_per_layer    size_MB = (total_bits / 8) / (1024 ** 2)  # bits转换为MB    return size_MB