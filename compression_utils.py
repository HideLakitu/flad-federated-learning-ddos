"""尝试将STC(三元压缩)整合进FLAD中, 并评测其效果包括Residue(残差累积)模块"""import tensorflow as tfimport numpy as npdef approx_v(T, p):    """    估计稀疏化阈值v，选择前p%最大元素.    T: 模型更新的差异张量.    p: 稀疏率, 如0.001表示前0.1%的元素被保留.    """    T_flat = tf.reshape(tf.abs(T), -1)    k = tf.cast(tf.math.ceil(tf.size(T_flat, out_type=tf.float32) * p), tf.int32)    top_k, _ = tf.math.top_k(T_flat, k=k)    v = top_k[-1]  # 门槛    return v, top_kdef stc(T: tf.Tensor, hp):    """    STC稀疏三值压缩方法实现    T: 需要压缩的张量（模型差异）    hp: 超参数    返回压缩后的张量    """    hp_ = {'p': 0.1, 'approx': 1.0}    hp_.update(hp)    T_abs = tf.abs(T)    v, topk = approx_v(T_abs, hp_['p'])    mean = tf.reduce_mean(topk)    zeros = tf.zeros_like(T)    out_ = tf.where(T >= v, mean, zeros)    out = tf.where(T <= -v, -mean, out_)    return outdef decompress_stc(T_compressed):    """    因为STC只使用三值量化，因此解压缩就是直接返回压缩后的张量。    在实际应用中，这一步和压缩是对称的。    """    return T_compressed#  计算通讯量的方法def get_stc_update_size(T_compressed):    """    计算压缩后的STC模型更新通信量（MB）.    STC每个非零值使用1 bit表示，位置编码平均大约16 bit.    """    T_flat = tf.reshape(T_compressed, [-1])    k = tf.math.count_nonzero(T_flat, dtype=tf.float32)    total_bits = k * (1 + 16)  # 值编码1bit + 位置编码约16bits    size_MB = (total_bits / 8) / (1024**2)  # bits 转换为 MB    return size_MB.numpy()def calculate_compressed_update_size(compressed_update):    """    计算STC压缩后的通信量（MB）    compressed_update: 客户端压缩后的模型更新 (模型的各层)    每个非零值约17 bits (1位表示符号, 16位表示位置)    """    total_bits = 0    for layer in compressed_update:        nonzero_count = np.count_nonzero(layer)        bits_per_layer = nonzero_count * 17  # 每个非零元素17 bits        total_bits += bits_per_layer    size_MB = (total_bits / 8) / (1024 ** 2)  # bits转换为MB    return size_MB#  新增编码方法, golomb_encode()和golomb_decode()def get_golomb_bits(T_compressed, approx=True):    """    基于Golomb编码计算STC压缩后的通信量 (bits).    T_compressed: STC压缩后的张量 (numpy或tf.tensor)    approx: 是否使用近似估计（推荐True，计算效率高）    """    # 转换为numpy数组计算（确保效率）    T_flat = np.reshape(T_compressed, -1)    k = np.count_nonzero(T_flat)    N = T_flat.size    # STC方法值编码为1 bit (符号)    B_val = 1    # Golomb位置编码优化    q = (k + 1) / (N + 1)    golden = (np.sqrt(5) + 1) / 2    if q == 1:        return B_val * N    if q == 0:        return 0    b_star = 1 + np.floor(np.log2(np.log(golden - 1) / np.log(1 - q)))    if approx:        # 近似公式 (STC原始论文给出)        B_pos = b_star + (1 / (1 - (1 - q)**(2 ** b_star))) + 1    else:        # 精确计算（速度较慢，不推荐）        idc = np.nonzero(T_flat)[0]        distances = np.diff(np.concatenate((np.array([-1]), idc)))        B_pos = np.mean(np.ceil(distances / (2 ** b_star))) + (b_star + 1)    total_bits = (B_pos + B_val) * k    return total_bitsdef calculate_compressed_update_size_golomb(compressed_update, approx=True):    """    计算STC压缩（Golomb编码后）更新的总通信量(MB)    compressed_update: 客户端压缩后的更新 (list of tensors or numpy arrays)    """    total_bits = 0    for layer in compressed_update:        total_bits += get_golomb_bits(layer, approx)    size_MB = (total_bits / 8) / (1024 ** 2)  # bits转换为MB    return size_MB"""对之前的Golomb编码函数进行修改"""#  新增真实Golomb encode和decode函数def golomb_encode_sparse(T_compressed):    """    真实实现Golomb编码（适合STC的稀疏矩阵）    将稀疏的张量转化为(positions, signs, mean_value)的形式    """    T_flat = np.reshape(T_compressed, -1)    positions = np.nonzero(T_flat)[0].astype(np.int32)    signs = np.sign(T_flat[positions]).astype(np.int8)    mean_value = np.mean(np.abs(T_flat[positions]))    encoded_update = {        'positions': positions,        'signs': signs,        'mean': mean_value,        'shape': T_compressed.shape    }    return encoded_updatedef golomb_decode_sparse(encoded_update):    """    真实实现Golomb解码，还原稀疏矩阵    """    positions = encoded_update['positions']    signs = encoded_update['signs']    mean_value = encoded_update['mean']    shape = encoded_update['shape']    T_flat = np.zeros(np.prod(shape), dtype=np.float32)    T_flat[positions] = signs * mean_value    return T_flat.reshape(shape)def calculate_true_encoded_size(encoded_update):    """    计算真实Golomb编码后的通信量（MB）    使用Golomb编码估计位置大小，sign每个1 bit, mean_value 32 bits    """    positions = encoded_update['positions']    signs = encoded_update['signs']    mean_value_bits = 32  # mean_value使用32位浮点数存储    positions_bits = get_golomb_bits(np.array(positions))    signs_bits = len(signs)  # 每个符号1 bit    total_bits = positions_bits + signs_bits + mean_value_bits    size_MB = (total_bits / 8) / (1024 ** 2)    return size_MB